---
layout: post
title:  "Получение всех email-enabled объектов из Exchange со всеми адресам"
categories: [ Администрирование ]
tags: [ Powershell ]
image: assets/images/get-all-email-enabled-objects/0.jpg
author: Mikhail
---

***В этой статье я хочу рассказать об архитектуре приложения, реализующего функцию аутентификации и авторизации. Статья построена на минималистичном примере. Тут главное понять концепцию. Сделав это, приложение можно дополнить новым функционалом и включить в любое своё приложение.***

Для того, чтобы сделать функционал авторизации нужно иметь back-end приложение с API, при вызове которого мы будем получать информацию о том, что пользователь прошёл авторизацию. И front-end приложение, которое будет запрашивать API. В этой статье я хочу поговорить об архитектуре front-end приложения.

Я использую Rect и React Router. В нашем приложении у нас будет главная форма, не требующая авторизацию. Одна страница, вход на которую возможен только после успешной авторизации. И функция Logout.

Основная концепция заключается в том, что при переходе по ссылке, приложение проверяет состояние переменной в зависимости от этого пускает на страницу или перенаправляет на форму ввода пароля.

> Вместо переменной может быть всё, что угодно. Например JWT access и/или refresh token, SID пользователя, или что-то ещё. И хранить и получать эти данные можно из разных мест - Local Storage в браузере, Active Directory, БД, Web сервис или API. Всё зависит от сложности нашего приложения и типа авторизации, который мы хотим реализовать.

Допустим у нас есть несколько маршрутов. В представленном примере они себя ведут как обычно и тут пока нет никакой авторизации. При входе на сайт нас перенаправляют на компонент Main. Так же сейчас доступны все приведённые маршруты. А в случае, если мы запрашиваем несуществующую страницу, то получаем соответсвующую надпись.

routes.tsx
```tsx
import { Route, Routes } from 'react-router-dom';
import Login from '../pages/Login';
import Main from '../pages/Main';
import Admin from '../pages/Admin';

export const useRoutes = () => {

  return (
    <Routes>
      <Route index element={<Main />} />
      <Route path="/" element={<Main />} />
      <Route path="/admin" element={<Admin />} />
      <Route path="/login" element={<Login />} />

      <Route path="*" element={<p>There's nothing here: 404!</p>} />
    </Routes>
  )
}

export default useRoutes
```

Я хочу, чтобы при переходе на страницу `/admin` выводилась форма `/login`, в которой будут запрашиваться логин и пароль и отправляться на сервер. И в зависимости от ответа сервера приложение будет разрешать переход на страницу или нет. Для этого нам нужно реализовать компонент, задача которого принять решение - перенаправлять пользователя на запрошенную страницу или нет.

Вот как мог бы выглядеть такой компонент. Этот код является компонентом PrivateRoute, который используется для ограничения доступа к определенным маршрутам приложения только для авторизованных пользователей.

Первые две строки кода импортируют необходимые модули, а именно Navigate и Outlet из библиотеки react-router-dom, а также useAuth из пользовательского хука useAuth.

Затем определяется функциональный компонент PrivateRoute без параметров. Внутри этой функции вызывается хук useAuth, который позволяет проверить, авторизован ли пользователь.

Далее возвращается условный оператор. Если значение isAuthenticated равно true, то компонент Outlet будет возвращен. 

> Outlet является элементом из библиотеки react-router-dom, который рендерит дочерние элементы текущего маршрута. 

Если же значение isAuthenticated равно false, то будет возвращен компонент Navigate. 

> Navigate - это элемент из библиотеки react-router-dom, который перенаправляет пользователя на другой маршрут.

В данном случае, если пользователь не авторизован, то он будет перенаправлен на маршрут /login, который является страницей входа в приложение. Свойство replace указывает, что текущий маршрут будет заменен на новый, чтобы пользователь не мог вернуться обратно, используя кнопку "назад" в браузере.

Таким образом, этот компонент используется для ограничения доступа к защищенным маршрутам только для авторизованных пользователей, перенаправляя пользователей на страницу входа, если они не авторизованы.

PrivateRoute.tsx
```tsx
// импортируем необходимые модули из библиотеки react-router-dom и пользовательский хук useAuth
import { Navigate, Outlet } from "react-router-dom";
import useAuth from "../hooks/useAuth";

// определяем функциональный компонент PrivateRoute
export const PrivateRoute = () => {  

  // используем пользовательский хук useAuth, чтобы проверить, авторизован ли пользователь
  const {isAuthenticated} = useAuth()

  // возвращаем условный оператор для рендеринга компонентов на основе состояния isAuthenticated
  return (
    // если пользователь авторизован, то рендерим дочерние элементы текущего маршрута, используя компонент Outlet
    isAuthenticated === true ?
      <Outlet />
      // если пользователь не авторизован, то перенаправляем его на маршрут /login с помощью компонента Navigate
      // свойство replace указывает, что текущий маршрут будет заменен на новый, чтобы пользователь не мог вернуться обратно, используя кнопку "назад" в браузере
      :
      <Navigate to="/login" replace />
  )

};
```

Как видно, всё, что делает этот компонент - это получает результат из хука useAuth и решает рендерить запрошенную страницу или перенаправить на страницу `/login` для ввода логина/пароля.

А вот как использовать компонент `PrivateRoute`.

```tsx
... //остальные импорты
import { PrivateRoute } from '../components/PrivateRoute';

<Routes>

... //другие маршруты

      <Route element={<PrivateRoute />}>
        <Route path='/admin' element={<Admin />} />
		... //другие защищённые маршруты		
      </Route>

... //другие маршруты

</Routes>
```

Хук `useAuth` тоже предельно простой. Его единственная задача экспортировать контекст. По ![этой ссылке](https://gist.github.com/mdanshin/a32560926c69d06b33d427534abbf225) можно посмотреть самый простой пример работы с React Context.

useAuth.tsx
```tsx
import { useContext } from "react"
import AuthContext from "../context/AuthProvider"

function useAuth() {
  return (
    useContext(AuthContext)
  )
}

export default useAuth
```

Создаём контекст тоже самым примитивным образом.

AuthProvider.tsx
```tsx
import { createContext, useState } from "react";

type AuthContextType = {
  isAuthenticated: boolean;
  setAuth: (auth: boolean) => void;
};

const AuthContext = createContext<AuthContextType>({
  isAuthenticated: false,
  setAuth: () => { },
});

export const AuthProvider = ({ children }: { children: JSX.Element }) => {
  const [isAuthenticated, setAuth] = useState<boolean>(false);
  return (
    <AuthContext.Provider value={{ isAuthenticated, setAuth }}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthContext;
```

Не забываем обернуть наше приложение в созданный контекст.

index.tsx
```tsx
    <Router>
      <AuthProvider>
        <App />
      </AuthProvider>
    </Router>
```

Работа оставшейся части приложения сводится к тому, чтобы изменять значение переменной `isAuthenticated` в нужный момент. По умолчанию значение `isAuthenticated` равняется `false`. И мы не сможем попасть по нужному нам маршруту, т.к. в компоненте PrivateRoute имеется тернальный оператор, `isAuthenticated === true ? <Outlet /> : <Navigate to="/login" replace />` который перенаправит наш вызов на страницу `Login`, пока значение переменной будет `false`. Таким образом нам осталось только сделать страницу `Login`, вызвать там API нашего back-end-а или любым другим способом убедиться, что пользователь ввёл правильные имя и пароль и поменять значение `isAuthenticated` на `true` путём вызова метода setAuth.

Login.tsx
```tsx
const Login = () => {
  return(
    <button onClick={()=>{setAuth(true)}}>Login</button>
  )
}

export default Login
```

Конечно, приведённый выше пример - это самый примитивный вариант. Но сколько бы сложную реализацию аутнетификации вы не делали, в основе будет лежать примерно такой принцип:

1. Защита маршрута путём проверки разрешено пользователю получить доступ к старнице или нет. Критерием для доступа может служить текущее значение переменной, наличие токена доступа или что-то ещё.

2. Перенаправление на страницу авторизации

3. Получение подтверждения, что пользователь ввёл правильные логин/пароль

4. Перенаправление на запрошенную страницу

Одним из примеров реализации, может быть запрос токена доступа в ответ на ввод логина и пароля. Затем мы можем сохранить токен в localStorage и проверять его наличие каждый раз, при запросе защищённой старницы. Если токен имеется, то отправлять его на проверку и если проверка будет пройдена, то считать пользователя аутентифицированным.

> О том, что такое JWT я писал в своей статье ![JWT - коротко о главном](https://danshin.ms/jwt-quick-start/).

Другой, более правильный пример реализации, использование пары Refresh и Access токенов. Когда пользователь первый раз получает пару AccessToken/RefreshToken, то RefreshToken сохраняется как в базе данных на стороне сервера, вместе с id пользователя или другим уникальным идентификатором, так и на стороне клиента(пользователя). Как правило это HttpOnly-Cookie, которая хранится в браузере. Если после отправки AccessToken клиент получает ошибку 401 (Unauthorized Error), он отправляет RefreshToken на обновление токенов (/api/refresh) и после валидации RefreshToken сервер предоставляет новую пару AccessToken/RefreshToken. Клиент их принимает и заново отправляет AccessToken. Если на этот раз валидация прошла успешно, то сервер предоставляет доступ к запрашиваемому ресурсу.

Если же и RefreshToken не прошёл проверку, то пользователя просят заново пройти процесс аутентификации - ввести логин/пароль и заново получить пару AccessToken/RefreshToken.

> Обратите внимание, что данная схема не предполагает хранение AccessToken-а. Он как одноразовый пароль - получили, ввели и забыли. Нужно сказать, что время жизни AccessToken-а нужно устанавливать всегда маленькое, несколько секунд. А вот время RefreshToken-а должно быть такое, чтобы, с одной стороны, не надоедать пользователю часстым вводом логина/пароля, с другой, не хранить его долго, потому, что он может быть украден или скомпромитирован. Например RefreshToken можено хранить 30 дней.